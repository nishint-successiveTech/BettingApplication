import type { TSchema } from '@sinclair/typebox/build/cjs/type/schema';
import type { Assert, Ensure } from '@sinclair/typebox/build/cjs/type/helpers';
import type { TMappedResult } from '@sinclair/typebox/build/cjs/type/mapped';
import type { SchemaOptions } from '@sinclair/typebox/build/cjs/type/schema';
import { type TLiteral, type TLiteralValue } from '@sinclair/typebox/build/cjs/type/literal';
import { type TNumber } from '@sinclair/typebox/build/cjs/type/number';
import { TComputed } from '@sinclair/typebox/build/cjs/type/computed';
import { type TRef } from '@sinclair/typebox/build/cjs/type/ref';
import { type TKeyOfPropertyKeys } from '@sinclair/typebox/build/cjs/type/keyof/keyof-property-keys';
import { type TUnionEvaluated } from '@sinclair/typebox/build/cjs/type/union';
import { type TKeyOfFromMappedResult } from '@sinclair/typebox/build/cjs/type/keyof/keyof-from-mapped-result';
type TFromComputed<Target extends string, Parameters extends TSchema[]> = Ensure<TComputed<'KeyOf', [TComputed<Target, Parameters>]>>;
type TFromRef<Ref extends string> = Ensure<TComputed<'KeyOf', [TRef<Ref>]>>;
/** `[Internal]` Used by KeyOfFromMappedResult */
export type TKeyOfFromType<Type extends TSchema, PropertyKeys extends PropertyKey[] = TKeyOfPropertyKeys<Type>, PropertyKeyTypes extends TSchema[] = TKeyOfPropertyKeysToRest<PropertyKeys>, Result = TUnionEvaluated<PropertyKeyTypes>> = Ensure<Result>;
export type TKeyOfPropertyKeysToRest<PropertyKeys extends PropertyKey[], Result extends TSchema[] = []> = (PropertyKeys extends [infer L extends PropertyKey, ...infer R extends PropertyKey[]] ? L extends '[number]' ? TKeyOfPropertyKeysToRest<R, [...Result, TNumber]> : TKeyOfPropertyKeysToRest<R, [...Result, TLiteral<Assert<L, TLiteralValue>>]> : Result);
export declare function KeyOfPropertyKeysToRest<PropertyKeys extends PropertyKey[]>(propertyKeys: [...PropertyKeys]): TKeyOfPropertyKeysToRest<PropertyKeys>;
export type TKeyOf<Type extends TSchema> = (Type extends TComputed<infer Target extends string, infer Parameters extends TSchema[]> ? TFromComputed<Target, Parameters> : Type extends TRef<infer Ref extends string> ? TFromRef<Ref> : Type extends TMappedResult ? TKeyOfFromMappedResult<Type> : TKeyOfFromType<Type>);
/** `[Json]` Creates a KeyOf type */
export declare function KeyOf<Type extends TSchema>(type: Type, options?: SchemaOptions): TKeyOf<Type>;
export {};
