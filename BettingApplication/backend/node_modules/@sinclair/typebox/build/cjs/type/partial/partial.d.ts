import type { TSchema, SchemaOptions } from '@sinclair/typebox/build/cjs/type/schema';
import type { Evaluate, Ensure } from '@sinclair/typebox/build/cjs/type/helpers';
import type { TMappedResult } from '@sinclair/typebox/build/cjs/type/mapped';
import { type TReadonlyOptional } from '@sinclair/typebox/build/cjs/type/readonly-optional';
import { type TComputed } from '@sinclair/typebox/build/cjs/type/computed';
import { type TOptional } from '@sinclair/typebox/build/cjs/type/optional';
import { type TReadonly } from '@sinclair/typebox/build/cjs/type/readonly';
import { type TRecursive } from '@sinclair/typebox/build/cjs/type/recursive';
import { type TObject, type TProperties } from '@sinclair/typebox/build/cjs/type/object';
import { type TIntersect } from '@sinclair/typebox/build/cjs/type/intersect';
import { type TUnion } from '@sinclair/typebox/build/cjs/type/union';
import { type TRef } from '@sinclair/typebox/build/cjs/type/ref';
import { type TBigInt } from '@sinclair/typebox/build/cjs/type/bigint';
import { type TBoolean } from '@sinclair/typebox/build/cjs/type/boolean';
import { type TInteger } from '@sinclair/typebox/build/cjs/type/integer';
import { type TLiteral } from '@sinclair/typebox/build/cjs/type/literal';
import { type TNull } from '@sinclair/typebox/build/cjs/type/null';
import { type TNumber } from '@sinclair/typebox/build/cjs/type/number';
import { type TString } from '@sinclair/typebox/build/cjs/type/string';
import { type TSymbol } from '@sinclair/typebox/build/cjs/type/symbol';
import { type TUndefined } from '@sinclair/typebox/build/cjs/type/undefined';
import { type TPartialFromMappedResult } from '@sinclair/typebox/build/cjs/type/partial/partial-from-mapped-result';
type TFromComputed<Target extends string, Parameters extends TSchema[]> = Ensure<TComputed<'Partial', [TComputed<Target, Parameters>]>>;
type TFromRef<Ref extends string> = Ensure<TComputed<'Partial', [TRef<Ref>]>>;
type TFromProperties<Properties extends TProperties> = Evaluate<{
    [K in keyof Properties]: Properties[K] extends (TReadonlyOptional<infer S>) ? TReadonlyOptional<S> : Properties[K] extends (TReadonly<infer S>) ? TReadonlyOptional<S> : Properties[K] extends (TOptional<infer S>) ? TOptional<S> : TOptional<Properties[K]>;
}>;
type TFromObject<Type extends TObject, Properties extends TProperties = Type['properties']> = Ensure<TObject<(TFromProperties<Properties>)>>;
type TFromRest<Types extends TSchema[], Result extends TSchema[] = []> = (Types extends [infer L extends TSchema, ...infer R extends TSchema[]] ? TFromRest<R, [...Result, TPartial<L>]> : Result);
export type TPartial<Type extends TSchema> = (Type extends TRecursive<infer Type extends TSchema> ? TRecursive<TPartial<Type>> : Type extends TComputed<infer Target extends string, infer Parameters extends TSchema[]> ? TFromComputed<Target, Parameters> : Type extends TRef<infer Ref extends string> ? TFromRef<Ref> : Type extends TIntersect<infer Types extends TSchema[]> ? TIntersect<TFromRest<Types>> : Type extends TUnion<infer Types extends TSchema[]> ? TUnion<TFromRest<Types>> : Type extends TObject<infer Properties extends TProperties> ? TFromObject<TObject<Properties>> : Type extends TBigInt ? Type : Type extends TBoolean ? Type : Type extends TInteger ? Type : Type extends TLiteral ? Type : Type extends TNull ? Type : Type extends TNumber ? Type : Type extends TString ? Type : Type extends TSymbol ? Type : Type extends TUndefined ? Type : TObject<{}>);
/** `[Json]` Constructs a type where all properties are optional */
export declare function Partial<MappedResult extends TMappedResult>(type: MappedResult, options?: SchemaOptions): TPartialFromMappedResult<MappedResult>;
/** `[Json]` Constructs a type where all properties are optional */
export declare function Partial<Type extends TSchema>(type: Type, options?: SchemaOptions): TPartial<Type>;
export {};
